<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Cocos2d-html5 - Basic input control</title>

    <link rel="stylesheet" href="../common/css/genericons.css">
    <link rel="stylesheet" href="../common/css/templatestyles.css">
    <link rel="stylesheet" href="../common/css/demos.css">
    <link rel="stylesheet" href="../common/stylesheets/pygment_trac.css">
    <link rel="stylesheet" id="open-sans-css"
          href="//fonts.googleapis.com/css?family=Open+Sans%3A300italic%2C400italic%2C600italic%2C300%2C400%2C600&amp;subset=latin%2Clatin-ext&amp;ver=4.1.1"
          type="text/css" media="all">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-17485141-5', 'auto');
      ga('send', 'pageview');

    </script>
</head>
<body>

<button class="toggle" id="menutoggle">
</button>
<div class="wrapper">
<header>

    <div class="site-title">
        <div class="site-title-info">
            <h1>Cocos2d-html5</h1>
        </div>
        <div id="menu" class="site-menu">
            <div id="menuclose" class="close-button"><span class="icon-close"></span></div>
            <p class="demos-menu-title">Demos list</p>
            <ul id="site-menu" >

            </ul>
        </div>
    </div>
</header>

    <section>
        <div style="position:relative">
            <canvas id="c"></canvas>
            <span id="span" class="infospan"></span>
        </div>
        <div>
            <p>
                This demo showcases input system. The Magenta nodes are in scene-graph order, so that overlapping elements
                get input first.
            </p>
            <p>
                The red node has prioritized order so gets input first even though is has overlapping Nodes.
            </p>
        </div>
    </section>
    <footer>
        <p>This project is maintained by <a href="https://github.com/hyperandroid">hyperandroid</a></p>
    </footer>
</div>
    <script src="../../../javascripts/scale.fix.js"></script>
    <script src="../../../javascripts/menu.js"></script>
    <script src="../../../dist/all.js"></script>
<script>
    (function() {
        document.getElementById("menutoggle").addEventListener("click", function(e) {
            e.preventDefault();
            document.getElementById("menu").style["display"]="block";
        }, false );
        document.getElementById("menuclose").addEventListener("click", function(e) {
            e.preventDefault();
            document.getElementById("menu").style["display"]="none";
        }, false );

        var W=700;
        var H=600;
        var span= null;

        function initialize() {

            cc.render.RENDER_ORIGIN=cc.render.ORIGIN_TOP;

            // the renderer will setup pre-loaded textures for the renderer type.
            // it will also create necessary SpriteFrames for each texture, in this case a frame for the image dude.png
            var renderer= new cc.render.CanvasRenderer(W,H,document.getElementById("c"));

            // director is the main Cocos Node, and must exist.
            var director= new cc.node.Director().
                    setRenderer( renderer );

            // scenes run in directors, and are the main displayable element.
            var scene= director.createScene().setColor(.9,.9,.9);


            createNodeAndChildren(
                    100,100,cc.math.Color.RED, cc.math.Color.CYAN,
                    20, 20, cc.math.Color.GREEN,   cc.math.Color.BLUE,
                    scene, 10
            );

            for( var i=0; i<30; i++ ) {
                createNodeAndChildren(
                        100,100,cc.math.Color.MAGENTA,cc.math.Color.createFromRGBA(255,128,0,255),
                        20, 20, cc.math.Color.BLUE,   cc.math.Color.YELLOW,
                        scene, 0
                ).setName("name"+i);
            }

            // run the scene.
            director.runScene( scene );

            createInfo();
        }

        function createNodeAndChildren(pw,ph,pcolor,pcolorin, cw,ch,ccolor,ccolorin, scene, priority) {

            var node= createNode(pw,ph,pcolor,pcolorin).
                    setPosition( 50+(W-100)*Math.random(), 50+(H-100)*Math.random());
            node.draw= function(ctx) {


                ctx.setFillStyleColor(this._color);
                ctx.fillRect(0,0,this._contentSize.width,this._contentSize.height);


                ctx.strokeStyle="#000";
                ctx.strokeRect(0,0,this._contentSize.width,this._contentSize.height);

                ctx.lineWidth=2;
                ctx.strokeStyle= "#fff";
                ctx.beginPath();
                ctx.moveTo(3,8);
                ctx.lineTo(15,8);
                ctx.lineTo(10,3);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(3,8);
                ctx.lineTo(15,8);
                ctx.lineTo(10,13);
                ctx.stroke();

            };

            node.addChild( createNode(cw,ch,ccolor,ccolorin) );
            node.addChild( createNode(cw,ch,ccolor,ccolorin) );

            scene.addChild(node);

            if (!priority) {
                node.enableEvents(true);
                node._children[0].enableEvents(true);
                node._children[1].enableEvents(true);
            } else {

                node._children[1].enablePriorityEvents(true, priority);
                node._children[0].enablePriorityEvents(true, priority);
                node.enablePriorityEvents(true, priority);
            }

            return node;
        }

        function createNode(w,h,color,colorIn) {
            var node= new cc.node.Node().
                    setContentSize(w,h).
                    setRotation( Math.random()*360).
                    setPosition( 20+60*Math.random(), 20+60*Math.random());

            node._color= color;

            node.addEventListener( "mouseover", function(e) {
                e.target._color= colorIn;
                posInfo(e);
            });
            node.addEventListener( "mousedown", function(e) {
                e.target._color= colorIn;
                posInfo(e);
            });
            node.addEventListener( "mouseout", function(e) {
                e.target._color= color;
                posInfo(null);
            });
            node.addEventListener( "mouseup", function(e) {
                e.target._color= color;
                posInfo(null);
            });
            node.addEventListener( "mousemove", function(e) {
                posInfo(e);
            });
            node.addEventListener( "mousedrag", function(e) {

                posInfo(e);

                // If everything were axis aligned, all this code from below, would be unnecessary.
                // In this demo, nodes are arbitrarily positioned and rotated, and have children with the
                // same constraints. This code is necessary to normalize node position based on an arbitrary
                // deep-nested affine transform.
                // this code guarantess that moving the mouse/touch to the right will make the Node move the same
                // amount of pixels, regardless where and how deeply affine transformed is.

                var node= e.target;
                var parent= e.target._parent;

                // get local in-node coordinate.
                var p0= new cc.math.Vector();
                p0.set(e.localPoint.x, e.localPoint.y);
                // transform it to screen space
                var matrix= node._worldModelViewMatrix;
                cc.math.Matrix3.transformPoint( matrix, p0 );

                // get previous screen space coordinate
                var p1= new cc.math.Vector();
                p1.set(e.prevScreenPoint.x, e.prevScreenPoint.y);

                // transform both screen coordinates to local space.
                var matrixp= parent.getInverseWorldModelViewMatrix();
                cc.math.Matrix3.transformPoint( matrixp, p0 );
                cc.math.Matrix3.transformPoint( matrixp, p1 );

                // add the difference to current node position.
                node.x+= p0.x - p1.x;
                node.y+= p0.y - p1.y;

            });

            node.draw= function( ctx ) {

                ctx.strokeStyle="#000";
                ctx.strokeRect(0,0,this._contentSize.width,this._contentSize.height);

                ctx.setFillStyleColor(this._color);
                ctx.fillRect(0,0,this._contentSize.width,this._contentSize.height);

                ctx.setFillStyleColorArray([1,1,1]);
                ctx.fillRect(3,3,5,5);
            };

            return node;
        }

        function createInfo() {
            span= document.getElementById("span");
        }

        function posInfo(e) {
            if (e) {

                var sx= ((e.screenPoint.x*100)|0)/100.0;
                var sy= ((e.screenPoint.y*100)|0)/100.0;
                var lx= ((e.localPoint.x*100)|0)/100.0;
                var ly= ((e.localPoint.y*100)|0)/100.0;

                span.innerHTML = "Screen point: (" + sx +","+ sy+") " +
                        "Local point: (" + lx +","+ ly +")";
            } else {
                span.innerHTML = "No Node selected.";
            }
        }

        window.addEventListener("DOMContentLoaded", initialize, false);

    })();
</script>


</body>
</html>